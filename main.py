import math
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh
#np.seterr(divide='ignore', invalid='ignore')
#Введём необходимые переменные
C_11A=8.1*10**15
C_12A=8.1*10**15
C_21A=8.1*10**15
C_22A=8.1*10**15
C_44A=8.1*10**15
C_11B=0.148*10**15
C_12B=0.148*10**15
C_21B=0.148*10**15
C_22B=0.148*10**15
C_44B=0.148*10**15
c=3*10**8
a11=1
a12=0
a13=0
a21=0
a22=1
a23=0
a31=0
a32=0
a33=1
r_0=[0.01, 0, 0]
a=0.05
rho_a=7780
rho_b=1142

#Зададим базис прямой решётки
a1=[a11,a12,a13]
a2=[a21,a22,a23]
a3=[a31,a32,a33]

#Найдём объём элементарной ячейки
V=a11*(a22*a33-a23*a32)+a12*(a23*a31-a21*a33)+a13*(a21*a32-a22*a31)

#Найдём базис обратной решётки
b1=[2*math.pi*(a22*a33-a23*a32)/V, 2*math.pi*(a23*a31-a21*a33)/V, 2*math.pi*(a21*a32-a22*a31)/V]
b2=[2*math.pi*(a32*a13-a33*a12)/V, 2*math.pi*(a31*a13-a33*a11)/V, 2*math.pi*(a31*a12-a32*a11)/V]
b3=[2*math.pi*(a12*a23-a13*a22)/V, 2*math.pi*(a11*a23-a13*a21)/V, 2*math.pi*(a11*a22-a12*a21)/V]

#Найдём длины базисных векторов обратной решётки
b1_length=(b1[0]**2+b1[1]**2+b1[2]**2)**0.5
b2_length=(b2[0]**2+b2[1]**2+b2[2]**2)**0.5
b3_length=(b3[0]**2+b3[1]**2+b3[2]**2)**0.5

#Найдём длину r_0
r0_lenght=(r_0[0]**2+r_0[1]**2+r_0[2]**2)**0.5

#Создадим массивы, в которые будем добавлять вектора Блоха К, вектора G' и вектора G''
K=np.zeros((15625,3))
G_1=np.zeros((15625,3))
d=0
for i in range(1,26):
  for j in range(1,26):
    for w in range(1,26):
      K[d][0]=(math.pi/(a11**2+a12**2+a13**2)**0.5)*0.5/26*i
      K[d][1]=(math.pi/(a21**2+a22**2+a23**2)**0.5)*0.5/26*j
      K[d][2]=(math.pi/(a31**2+a32**2+a33**2)**0.5)*0.5/26*w
      G_1[d][0]=(math.pi/b1_length)/3*i
      G_1[d][1]=(math.pi/b2_length)/3*j
      G_1[d][2]=(math.pi/b3_length)/3*w
      d=d+1

#Определим гамма-функцию Эйлера
def eiler(n):
  e=1
  for i in range(1,n):
    e=e*i
  return e

#Определим функцию Бесселя первого порядка
def J1(x):
  J=0
  for m in range(0,6):
    J=J+((-1)**m)/(eiler(m+1)*eiler(m+2))*(x/2)**(2*m+1)
  return J

#Создадим массив заполненный векторами G'' для частного случая квадратной решётки со стороной a и массив заполненный плотностями. Также массив содержащий вектора G. И массив с C_ijkl
G_11=np.zeros((15625,3))
rho_11=np.zeros((1,15625))
C_11=np.zeros((1,15625))
C_12=np.zeros((1,15625))
C_21=np.zeros((1,15625))
C_22=np.zeros((1,15625))
C_44=np.zeros((1,15625))
G=np.zeros((15625,3))
d=0

#Рисуем график
plt.figure()

for x in range(-62,63):
  for y in range(-62,63):
    G_11[d][0]=(2*math.pi/a)*x
    G_11[d][1]=(2*math.pi/a)*y
    G_11[d][2]=(2*math.pi/a)*0
    rho_11[0][d]=(rho_a-rho_b)*2*(math.pi*r0_lenght**2/a)*J1(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])/(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])
    C_11[0][d]=(C_11A-C_11B)*2*(math.pi*r0_lenght**2/a)*J1(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])/(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])
    C_12[0][d]=(C_12A-C_12B)*2*(math.pi*r0_lenght**2/a)*J1(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])/(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])
    C_21[0][d]=(C_21A-C_21B)*2*(math.pi*r0_lenght**2/a)*J1(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])/(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])
    C_22[0][d]=(C_22A-C_22B)*2*(math.pi*r0_lenght**2/a)*J1(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])/(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])
    C_44[0][d]=(C_44A-C_44B)*2*(math.pi*r0_lenght**2/a)*J1(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])/(G_11[d][0]*r_0[0]+G_11[d][1]*r_0[1])
    G[d][0]=G_11[d][0]+G_1[d][0]
    G[d][1]=G_11[d][1]+G_1[d][1]
    G[d][2]=G_11[d][2]+G_1[d][2]
    d=d+1

#Создадим матрицы A и B и решим соответствующие уравнение
omega_solve=np.zeros((1,1000000))
k_solve=np.zeros((1,1000000))
d=0
for i in range (0,15625):
  B_11=rho_11[0][i]
  B_22=rho_11[0][i]
  B_33=rho_11[0][i]
  A_11=C_11[0][d]*(G[i][0]+K[i][0])*(G_1[i][0]+K[i][0])+C_44[0][d]*(G[i][1]+K[i][1])*(G_1[i][1]+K[i][1])
  A_12=C_12[0][d]*(G[i][0]+K[i][0])*(G_1[i][1]+K[i][1])+C_44[0][d]*(G_1[i][0]+K[i][0])*(G[i][1]+K[i][1])
  A_21=C_12[0][d]*(G_1[i][0]+K[i][0])*(G[i][1]+K[i][1])+C_44[0][d]*(G_1[i][1]+K[i][1])*(G[i][0]+K[i][0])
  A_22=C_11[0][d]*(G[i][1]+K[i][1])*(G_1[i][1]+K[i][1])+C_44[0][d]*(G[i][0]+K[i][0])*(G_1[i][0]+K[i][0])
  A_33=C_44[0][d]*((G[i][0]+K[i][0])*(G_1[i][0]+K[i][0])+(G[i][1]+K[i][1])*(G_1[i][1]+K[i][1]))
  B=[[B_11, 0, 0], [0, B_22, 0], [0, 0, B_33]]
  A=[[A_11, A_12, 0], [A_21, A_22, 0], [0, 0, A_33]]
  k=K[i][0]*b1_length+K[i][1]*b2_length+K[i][2]*b3_length
  if np.linalg.det(B)>0:
      eigvals = eigh(A,B,eigvals_only=True)
      b = [x ** 0.5 for x in eigvals]
      plt.scatter([k]*len(eigvals),b,s=2,c='red')

#Нанесём точки на график
plt.show()